Content-type: text/html

<HTML><HEAD><TITLE>Manpage of GEOPM_PROF_C</TITLE>
</HEAD><BODY>
<H1>GEOPM_PROF_C</H1>
Section: GEOPM (3)<BR>Updated: 2015-10-16<BR><A HREF="#index">Index</A>
<A HREF="/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

geopm_prof_c - geopm application profiling structure
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/geopm.h">geopm.h</A>&gt;</B>

<B>Link with -lgeopm</B>

<B>int geopm_prof_create(const char *</B><I>name</I><B>,</B>
<B>                      int </B><I>sample_reduce</I><B>,</B>
<B>                      const char *</B><I>sample_key,</I>
<B>                      struct geopm_prof_c **</B><I>prof</I><B>);</B>

<B>int geopm_prof_destroy(struct geopm_prof_c *</B><I>prof</I><B>);</B>

<B>int geopm_prof_register(struct geopm_prof_c *</B><I>prof</I><B>,</B>
<B>                        const char *</B><I>region_name</I><B>,</B>
<B>                        long </B><I>policy_hint</I><B>,</B>
<B>                        int *</B><I>region_id</I><B>);</B>

<B>int geopm_prof_enter(struct geopm_prof_c *</B><I>prof</I><B>,</B>
<B>                     int </B><I>region_id</I><B>);</B>

<B>int geopm_prof_exit(struct geopm_prof_c *</B><I>prof</I><B>,</B>
<B>                    int </B><I>region_id</I><B>);</B>

<B>int geopm_prof_progress(struct geopm_prof_c *</B><I>prof</I><B>,</B>
<B>                        int </B><I>region_id</I><B>,</B>
<B>                        double </B><I>fraction</I><B>);</B>

<B>int geopm_prof_outer_sync(struct geopm_prof_c *</B><I>prof</I><B>);</B>

<B>int geopm_prof_sample(struct geopm_prof_c *</B><I>prof</I><B>);</B>

<B>int geopm_prof_disable(struct geopm_prof_c *</B><I>prof</I><B>,</B>
<B>                       const char *</B><I>feature_name</I><B>);</B>

<B>int geopm_prof_print(struct geopm_prof_c *</B><I>prof</I><B>,</B>
<B>                     int </B><I>depth</I><B>);</B>

<B>int geopm_prof_fprint(struct geopm_prof_c *</B><I>prof</I><B>,</B>
<B>                      int </B><I>depth</I><B>,</B>
<B>                      FILE *</B><I>fid</I><B>);</B>

<B>HELPER FUNCTIONS:</B>

<B>int geopm_omp_sched_static_norm(int </B><I>num_iter</I><B>,</B>
<B>                                int </B><I>chunk_size,</I>
<B>                                int </B><I>num_thread,</I>
<B>                                double *</B><I>norm</I><B>);</B>

<B>double geopm_progress_threaded_min(int </B><I>num_thread</I><B>,</B>
<B>                                   size_t </B><I>stride</I><B>,</B>
<B>                                   const uint32_t *</B><I>progress</I><B>,</B>
<B>                                   const double *</B><I>norm</I><B>);</B>

<B>double geopm_progress_threaded_sum(int </B><I>num_thread</I><B>,</B>
<B>                                   size_t </B><I>stride</I><B>,</B>
<B>                                   const uint32_t *</B><I>progress</I><B>,</B>
<B>                                   double </B><I>norm);</I>


</PRE><A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>

The geopm_prof_c structure enables application profiling for geopm.  The
functions associated with he geopm_prof_c structure are described here.  These
functions enable application feedback to the control algorithm for identifying
regions of code, progress within regions, and global synchronization points in
the application.  Regions of code define periods in the application during
which control parameters are tuned with the expectation that control
parameters for a region can be optimized independently of other regions.  In
this way a region is associated with a set of control parameters which can be
optimized, and future time intervals associated with the same region will
benefit from the application of control parameters which were determined from
tuning within previous occurrences of the region.  There are two competing
motivations for defining a region within the application.  The first is to
identify a section of code that has distinct compute, memory or network
characteristics.  The second is to avoid defining these regions such that they
are nested within each other, as nested regions are ignored, and only the
outer most region is used for tuning when nesting occurs.  Identifying
progress within a region can be used to alleviate load imbalance in the
application under the assumption that the region is bulk synchronous.  Under
the assumption that the application employs an iterative algorithm which
synchronizes periodically the user can alleviate load imbalance on larger time
scales than the regions provide.  This is done by marking the end of the outer
most loop, or the &quot;outer synchronization point.&quot;
<P>

<B>geopm_prof_create</B>()

creates a profile object
<I>prof</I>.

Requires a
<I>name</I>

which is displayed when the profile is printed.  The
<I>sample_reduce</I>

parameter determines the level of reduction that occurs when a sample is
generated with the
<B>geopm_prof_sample</B>()

API.  If
<I>sample_reduce</I>

is 0, no reduction occurs when sampling and samples include thread specific
information. If
<I>sample_reduce</I>

<BR>&nbsp;is&nbsp;1&nbsp;then&nbsp;thread&nbsp;specific&nbsp;data&nbsp;is&nbsp;aggregated&nbsp;to&nbsp;the&nbsp;MPI&nbsp;rank&nbsp;level.&nbsp;&nbsp;If
<I>sample_reduce</I>

is 2 then data is aggregated to the compute node granularity over all MPI
ranks on each compute node. If the
<I>sample_key</I>

is non-NULL then calls to
<B>geopm_prof_sample</B>()

will write the sampled data to POSIX shared memory associated with the given
key to be read by an external control process running on the same compute
node.
<B>geopm_prof_destroy</B>()

destroys all resources associated with the prof object.
<B>geopm_prof_register</B>()

registers an application region with the profile structure.  The
<I>region_name</I>

and
<I>hint</I>

are input parameters, and the
<I>region_id</I>

is returned.  If the region name has been previously registered, a call to
this function will set the
<I>region_id</I>

but the state in the
<I>prof</I>

structure associated with the region is unmodified.  The
<I>region_name</I>

is used to determine the output
<I>region_id</I>

and is also displayed in the profiling report to identify the region.   The
<I>hint</I>

is one of the values given by the geopm_prof_hint_e enum defined in
<I>geopm.h</I>

which determines the initial control settings.
<B>geopm_prof_enter</B>()

is called by the compute application to mark the beginning of
the profiled compute region associated with the
<I>region_id</I>.

If this call is made after entering a different region, but before exiting
that region, the call is ignored and an error code is returned (i.e. nested
regions are ignored).
<B>geopm_prof_exit</B>()

is called by compute application to mark the end of a compute region.  If this
region is nested then the call is ignored and an error code is returned.
<P>

<B>geopm_prof_progress</B>()

is called by compute application in single threaded context to signal the
fractional progress,
<I>fraction</I>

through the work required to complete the region where
<I>fraction</I>

is between 0 and 1.  If the
<I>region_id</I>

does not match the
<I>region_id</I>

of the last call to geopm_prof_prof_enter() which was not nested, then this
call is ignored and an error code is returned.
<P>

<B>geopm_prof_outer_sync</B>()

is called just prior to the highest level global synchronization point in an
application.  This occurs in the application's outermost loop in an
iterative algorithm just prior to the last synchronizing MPI call.  There
should be just one place in an application code where this call occurs, and
it should be called repeatedly inside of a loop.
<P>

<B>geopm_prof_sample</B>()

is called to derive a sample base on the profiling information collected.
This may aggregate data as specified by the
<I>sample_reduce</I>

parameters passed when the
<I>prof</I>

structure was created.
<P>

<B>geopm_prof_disable</B>()

is called at application start up to disable a profiling feature.  By default
all profiling features available on the system are enabled.  The set of all
possible values for
<I>feature_name</I>

are: &quot;instr&quot;, &quot;flop&quot;, and &quot;joules&quot;.
<P>

<B>geopm_prof_print</B>()

writes a profile report to standard output based on the data collected so
far.  This is intended for use just prior to application termination.  All
profile information above the specified
<I>depth</I>

in the control tree hierarchy is contained in the report.  A depth of 0 gives
only statistics aggregated over all MPI processes.
<P>

<B>geopm_prof_fprint</B>()

writes the profile report to the file descriptor
<I>fid</I>

rather than standard output and is otherwise the same as
<B>geopm_prof_print</B>().

<P>
<B>HELPER FUNCTIONS:</B>

<P>
<B>geopm_num_node</B>()

sets
<I>num_node</I>

to the number of compute nodes associated with the communicator
<I>comm</I>.

A compute node is defined to be a shared memory coherency domain.  The product of the
elements of
<I>fan_out</I>

passed to
<B>geopm_ctl_create</B>()

must equal
<I>num_node</I>.

<P>

<B>geopm_no_omp_cpu</B>()

sets the
<I>no_omp</I>

<B><A HREF="/man/man2html?3+CPU_SET">CPU_SET</A></B>(3)

allocated with
<I>num_cpu</I>

bits to a mask which can be used with
<B><A HREF="/man/man2html?3+pthread_attr_setaffinity_np">pthread_attr_setaffinity_np</A></B>(3)

to bind the pthread created by
<B>geopm_ctl_pthread</B>()

to CPUs that do not have an OpenMP thread affinity.  The mask generated when
OpenMP threads are not statically affinitized is unreliable.  The
<I>no_omp</I>

mask is zeroed and an error code is returned when all online CPUs have an
OpenMP thread affinity.
<P>

<B>geopm_omp_sched_static_norm</B>()

calculates the
<I>norm</I>

array of length
<I>num_thread</I>

that can be used with
<B>geopm_ctl_prof_progress_threaded_min</B>()

in the case where a for loop is OpenMP parallel using the static scheduling
algorithm with the specified
<I>chunk_size</I>.

The
<I>num_iter</I>

parameter is the number of iterations specified in the for loop, and the
<I>num_thread</I>

parameter determines the number of OpenMP threads that are used to parallelize
the loop.
<P>

<B>geopm_progress_threaded_min</B>()

is called by a compute application by one thread in a multi-threaded context
using
<I>num_thread</I>

threads.  This function returns the fractional progress through the work
required to complete the region.  The fractional progress is calculated as the
minimum of the fractional progress of all of the threads that are given work,
i.e. the minimum over all
<I>i</I>

of
<BR>

<I>progress</I>[<I>stride</I>*<I>i</I>]*<I>norm</I>[<I>i</I>].

<BR>

Note that the
<I>progress</I>

array is assumed to be strided where the separation in number of integers of
valid progress is given by the parameter
<I>stride</I>.

The
<I>stride</I>

can be used to avoid performance loss due to false sharing since multiple
threads must write to the progress array simultaneously.  On the x86
architecture it is recommended that a stride of 16 or greater is used to have
each thread writing to a different 64 byte cache line.  The
<I>norm</I>

array is used to normalize the integer
<I>progress</I>

array such that each element of
<I>norm</I>

is the inverse of each strided value of the
<I>progress</I>

array upon completion of all work in the region.
<P>

<B>geopm_progress_threaded_sum</B>()

is called by a compute application by one thread in a multi-threaded context
using
<I>num_thread</I>

threads.  This function is very much like
<B>geopm_progress_threaded_min</B>()

except that it sums the values in the
<I>progress</I>

array and multiplies the sum of the strided progress values by
<I>norm</I>

where
<I>norm</I>

is the inverse of the sum of all progress values upon completion of all work.
The fractional progress is calculated as the sum of the progress of all of the
threads that are given work normalized by the inverse of the amount of
aggregate work assigned to all threads,
<I>norm</I>.

This can be less accurate for determining load imbalance than using
<B>geopm_progress_threaded_min</B>()

but is applicable in contexts where the amount of work assigned to each thread
is not known in advance, e.g. OpenMP dynamic scheduling.  The progress array
is assumed to be strided in the same way and for the same reasons as described
above for
<B>geopm_threaded_progress_min</B>().

<P>

<A NAME="lbAE">&nbsp;</A>
<H2>ERRORS</H2>

All functions described on this man page return an error code.  See
<B><A HREF="/man/man2html?3+geopm_error">geopm_error</A></B>(3)

for a full description of the error numbers and how to convert them to
strings.
<A NAME="lbAF">&nbsp;</A>
<H2>COPYRIGHT</H2>

Copyright (C) 2015 Intel Corporation. All rights reserved.
<A NAME="lbAG">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="/man/man2html?3+geopm">geopm</A></B>(3),

<B><A HREF="/man/man2html?3+geopm_ctl_c">geopm_ctl_c</A></B>(3),

<B><A HREF="/man/man2html?3+geopm_error">geopm_error</A></B>(3),

<B><A HREF="/man/man2html?3+geopm_omp">geopm_omp</A></B>(3),

<B><A HREF="/man/man2html?3+geopm_policy_c">geopm_policy_c</A></B>(3),

<B><A HREF="/man/man2html?3+geopm_version">geopm_version</A></B>(3),

<B><A HREF="/man/man2html?3+geopmctl">geopmctl</A></B>(3),

<B><A HREF="/man/man2html?3+geopmkey">geopmkey</A></B>(3),

<B><A HREF="/man/man2html?3+geopmpolicy">geopmpolicy</A></B>(3)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">ERRORS</A><DD>
<DT><A HREF="#lbAF">COPYRIGHT</A><DD>
<DT><A HREF="#lbAG">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 21:46:25 GMT, November 14, 2015
</BODY>
</HTML>
